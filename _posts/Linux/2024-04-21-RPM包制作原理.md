---
title: RPM包制作原理
date: 2024-04-21 13:17:00
tags: ["系统", "Linux", "RedHat", "内核"]
categories: ["Linux"]
render_with_liquid: false
permalink: /posts/2024-04-21-RPM包制作原理/
---
> https://my.oschina.net/guol/home

有时候为了部署自己的包更方便一些，我们会制作自己的RPM包，制作RPM包都有哪些步骤呢，学习这些步骤就是本文的目的。在Centos下制作RPM包依赖rpm-build这个包，所以需要提前安装好该软件包。

## > RPM生成要素

> - 生成rpm所用的文件列表或者源代码
> - 根据文件列表或者源代码生成rpm规范，也就是spec文件
> - 根据spec文件加工源码/文件的工具rpmbuild
> 在redhat下，rpm包的默认制作路径在/usr/src/redhat下：

- /usr/src/redhat
- - -BUILD #编译之前，如解压包后存放的路径
- - -BUILDROOT #编译后存放的路径
- - -RPMS #打包完成后rpm包存放的路径
- - -SOURCES #源包所放置的路径
- - -SPECS #spec文档放置的路径
- - -SPRMS #源码rpm包放置的路径

> centos并没有该目录，这可咋办，其实在那个目录制作rpm是没有关系的，只要设置好配置文件就行。一般我们都把源码打包成tar.gz格式然后存放于SOURCES路径下，而在SPECS路径下编写spec文档，通过命令打包后，默认会把打包后的rpm包放在RPMS下，而源码包会被放置在SRPMS下。

## ## 先看看rpmbuild命令的用法

- # 从spec文档建立有以下选项：
- - bp #只执行spec的%pre 段(解开源码包并打补丁，即只做准备)
- - bc #执行spec的%pre和%build 段(准备并编译)
- - bi #执行spec中%pre，%build与%install(准备，编译并安装)
- - bl #检查spec中的%file段(查看文件是否齐全)
- - ba #建立源码与二进制包(常用)
- - bb #只建立二进制包(常用)
- - bs #只建立源码包

## 从tarball包建立，与spec类似

```text
tp #对应-bp
tc #对应-bc
ti #对应-bi
ta #对应-ba
tb #对应-bb
ts #对应-bs

```

## 从源码包建立

```text
-rebuild #建立二进制包，通-bb
-recompile #同-bi

```

## rpmbuild的其他参数

```ini
-buildroot=DIRECTORY #确定以root目录建立包
-clean #完成打包后清除BUILD下的文件目录
-nobuild #不进行%build的阶段
-nodeps #不检查建立包时的关联文件
-nodirtokens
-rmsource #完成打包后清除SOURCES
-rmspec #完成打包后清除SPEC
-short-cricuit
-target=CPU-VENDOR-OS #确定包的最终使用平台

```

## 再来看看spec文件编写规则

```bash
# spec的关键字

Name:用来定义软件包的名称，后面可以使用%{name}的方式引用，不能包含空格，且必须唯一
Summary: 软件包的内容概要，只能用一句话来概括
Version: 软件的实际版本号，具体命令需跟源包一致，后面可以使用%{version}使用，不允许出现连字符'-'，会被认为非法字符
Release: 发布序列号，具体命令需跟源包一致，后面可以使用%{release}使用，一般是一个整数，也是rpm包版本信息的一部分
License: 软件授权方式，通常就是GPL
Source: 源代码包，可以带多个用Source1、Source2等源，后面也可以用%{source1}、%{source2}引用
buildroot在rpmbuild在制作rpm包的时候，会把编译生成的二进制文件和库文件先安装到一个临时目录，然后再结合spec文件从这个临时目录中提取文件 ，压缩生成rpm文件，这个临时目录就是buildroot所标示的目录
BuildRoot: 这个是安装或编译时使用的“虚拟目录”，考虑到多用户的环境，一般定义为：%{_tmppath}/%{name}-%{version}-%{release}-root
       该参数非常重要，因为在生成rpm的过程中，执行make install时就会把软件安装到上述的路径中，在打包的时候，同样依赖“虚拟目录”为“根目录”进行操作。后面可使用$RPM_BUILD_ROOT 方式引用。
URL: 软件的主页
Vendor: 发行商或打包组织的信息，例如RedFlag Co,Ltd
Disstribution: 发行版标识
Group: 软件分组，建议使用标准分组
----------------------------------------
        软件包所属类别，具体类别有：
        Amusements/Games （娱乐/游戏）
        Amusements/Graphics（娱乐/图形）
        Applications/Archiving （应用/文档）
        Applications/Communications（应用/通讯）
        Applications/Databases （应用/数据库）
        Applications/Editors （应用/编辑器）
        Applications/Emulators （应用/仿真器）
        Applications/Engineering （应用/工程）
        Applications/File （应用/文件）
        Applications/Internet （应用/因特网）
        Applications/Multimedia（应用/多媒体）
        Applications/Productivity （应用/产品）
        Applications/Publishing（应用/印刷）
        Applications/System（应用/系统）
        Applications/Text （应用/文本）
        Development/Debuggers （开发/调试器）
        Development/Languages （开发/语言）
        Development/Libraries （开发/函数库）
        Development/System （开发/系统）
        Development/Tools （开发/工具）
        Documentation （文档）
        System Environment/Base（系统环境/基础）
        System Environment/Daemons （系统环境/守护）
        System Environment/Kernel （系统环境/内核）
        System Environment/Libraries （系统环境/函数库）
        System Environment/Shells （系统环境/接口）
        User Interface/Desktops（用户界面/桌面）
        User Interface/X （用户界面/X窗口）
        User Interface/X Hardware Support （用户界面/X硬件支持）
---------------------------------------------------
Patch: 补丁源码，可使用Patch1、Patch2等标识多个补丁，使用%patch0或%{patch0}引用
prefix主要用于定义可重新定义安装位置的包，也就是在安装时可以通过--prefix来定义包的安装路径
Prefix: %{_prefix} 这个主要是为了解决今后安装rpm包时，并不一定把软件安装到rpm中打包的目录的情况。这样，必须在这里定义该标识，并在编写%install脚本的时候引用，才能实现rpm安装时重新指定位置的功能
Prefix: %{_sysconfdir} 这个原因和上面的一样，但由于%{_prefix}指/usr，而对于其他的文件，例如/etc下的配置文件，则需要用%{_sysconfdir}标识
Requires: 该rpm包所依赖的软件包名称，可以用>=或<=表示大于或小于某一特定版本，“>=”号两边需用空格隔开，而不同软件名称也用空格分开
Conflicts: 该包与哪些软件包冲突
Provides: 该包提供了什么，通常是包名或者虚拟包名
Packager: 打包者的信息，可以是名字或者邮件地址
%dscription 软件的详细说明，描述信息可以有多行，如果提供的描述信息是以空格开始的，则该信息单独显示在一行，如果信息前没有空格，则认为描述信息是一个段落

```

## spec的主体，主体中也包括了很多关键字和描述

```bash
%prep 预处理脚本，
%setup -n %{name}-%{version} 把源码包解压并放好
  注：可根据你的源码的名字格式，来确认解压后名字的格式，否则可能导致install的时候找不到对应的目录
◎补充一下
%setup 不加任何选项，仅将软件包打开。
%setup -n newdir 将软件包解压在newdir目录。
%setup -c 解压缩之前先产生目录。
%setup -b num 将第num个source文件解压缩。
%setup -T 不使用default的解压缩操作。
%setup -T -b 0 将第0个源代码文件解压缩。
%setup -q 指不显示输出（quietly）
%setup -c -n newdir 指定目录名称newdir，并在此目录产生rpm套件。
%patch 最简单的补丁方式，自动指定patch level。
%patch 0 使用第0个补丁文件，相当于%patch ?p 0。
%patch -s 不显示打补丁时的信息。
%patch -T 将所有打补丁时产生的输出文件删除。
%build 开始构建包
在/usr/src/redhat/BUILD/%{name}-%{version}目录中进行make的工作 ，常见写法：
make %{?_smp_mflags} OPTIMIZE="%{optflags}"
都是一些优化参数，定义在/usr/lib/rpm/marcros中
%install 开始把软件安装到虚拟的根目录中
在/usr/src/redhat/BUILD/%{name}-%{version}目录中进行make install的操作。这个很重要，因为如果这里的路径不对的话，则下面%file中寻找文件的时候就会失败。 常见内容有：
%makeinstall 这不是关键字，而是rpm定义的标准宏命令。也可以使用非标准写法：
make DESTDIR=$RPM_BUILD_ROOT install
或
make prefix=$RPM_BUILD_ROOT install
%clean 清理临时文件
通常内容为：
[ "$RPM_BUILD_ROOT" != "/" ] && rm -rf "$RPM_BUILD_ROOT"
※注意区分$RPM_BUILD_ROOT和$RPM_BUILD_DIR：
$RPM_BUILD_ROOT是指开头定义的BuildRoot，而$RPM_BUILD_DIR通常就是指/usr/src/redhat/BUILD，其中，前面的才是%file需要的。
%pre rpm安装前执行的脚本
%post rpm安装后执行的脚本
%preun rpm卸载前执行的脚本
%postun rpm卸载后执行的脚本
%preun %postun 的区别是什么呢？
前者在升级的时候会执行，后者在升级rpm包的时候不会执行
%files 定义那些文件或目录会放入rpm中
这里会在虚拟根目录下进行，千万不要写绝对路径，而应用宏或变量表示相对路径。如果描述为目录，表示目录中除%exclude外的所有文件。
%deffattr (-,root,root) 指定包装文件的属性，分别是(mode,owner,group)，-表示默认值，对文本文件是0644，可执行文件是0755
%exclude 列出不想打包到rpm中的文件
※小心，如果%exclude指定的文件不存在，也会出错的。
%changelog 变更日志

```

## spec文档中常用的几个宏(变量)

```bash
RPM_BUILD_DIR:    /usr/src/redhat/BUILD
RPM_BUILD_ROOT:   /usr/src/redhat/BUILDROOT
%{_sysconfdir}:   /etc
%{_sbindir}：     /usr/sbin
%{_bindir}:       /usr/bin
%{_datadir}:      /usr/share
%{_mandir}:       /usr/share/man
%{_libdir}:       /usr/lib64
%{_prefix}:       /usr
%{_localstatedir}:   /usr/var

```

> 其实以上参数值都是在/usr/lib/rpm/macros文件中定义的，笔者在第一次制作rpm包时直接修改的该文件的值，其实最好不要修改该文件的值，只需要在家目录定义自己需要的值即可。