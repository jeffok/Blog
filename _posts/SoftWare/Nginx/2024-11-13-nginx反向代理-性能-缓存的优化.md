---
title: nginx反向代理-性能-缓存的优化
date: 2024-11-13 09:13:00
tags: ["Nginx", "Web服务器"]
categories: ["SoftWare", "Nginx"]
render_with_liquid: false
permalink: /posts/2024-11-13-nginx反向代理-性能-缓存的优化/
---

本文档介绍 nginx反向代理-性能-缓存的优化 的相关内容。

## nginx.conf

```text
nginx.conf

user  nginx;

# 打开逻辑CPU数

worker_processes  16;

# 为worker_processes绑定CPU

worker_cpu_affinity 0000000000000001 0000000000000010 0000000000000100 0000000000001000 0000000000010000 0000000000100000 0000000001000000 0000000010000000 0000000100000000 0000001000000000 0000010000000000 0000100000000000 0001000000000000 0010000000000000 0100000000000000 1000000000000000;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

# 修改worker运行用户的最大文件打开数值，worker_processes * worker_connections

worker_rlimit_nofile 65536;

events {
    #epoll是多路复用IO(I/O Multiplexing)中的一种方式
    use epoll;
    #在Nginx获得有新连接的通知之后,接受尽可能多的连接
    #需要注意的是:如果worker_connections设置太低的话,这样可能会造成拥堵
    multi_accept on;
    #设置网路连接序列化，防止惊群现象发生，如果访问量大，就打开
    accept_mutex off;
    #每个进程允许的最多连接数
    worker_connections 4096;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main  buffer=16k;
    #缓冲日志写入可以加速I/O,或是有可能的话甚至可以禁止,看具体的生产环境要求.
    access_log off;

    #关闭错误页面中nginx版本号
    server_tokens off;

    #立即将数据从磁盘读到OS缓存。这种拷贝是在内核完成的
    sendfile        on;
    #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。
    sendfile_max_chunk 512k;
    #告诉nginx在一个数据包里发送所有头文件，而不一个接一个的发送。
    tcp_nopush       on;
    #告诉nginx不要缓存数据，而是一段一段的发送--当需要及时发送数据时
    tcp_nodelay      on;

    #缓存打开的文件描述符(open FDs),经常被访问的文件的信息.
    #当设置下面这些值可以极大提高每秒的请求数.
    #实际设置的值不一定跟下面的一样,请根据具体机器来调优.下面只是测试环境中的一个设置例子.
    #max指定缓存数量   inactive是指经过多长时间文件没被请求后删除缓存
    open_file_cache max=65535 inactive=20s;
    #这个是指多长时间检查一次缓存的有效信息。也就是说即使我一直访问这个文件，30s后会检查此文件的更改信息是否变化，发现变化就更新。
    open_file_cache_valid 30s;
    #指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件更改信息一直是在缓存中打开的
    open_file_cache_min_uses 2;
    #指定了当搜索一个文件时是否缓存错误信息，也包括再次给配置中添加文件
    open_file_cache_errors on;

    #给客户端分配keep-alive链接超时时间。服务器将在这个超时时间过后关闭链接
    keepalive_timeout  65;
    # 在客户端停止响应之后,允许服务器关闭连接,释放socket关联的内存
    reset_timedout_connection on;
    #此指令设置NGINX能处理的最大请求主体大小。 如果请求大于指定的大小，则NGINX发回HTTP 413（Request Entity too large）错误。
    #如果服务器处理大文件上传，则该指令非常重要
    client_max_body_size 50m;
    #此指令设置用于请求主体的缓冲区大小。 如果主体超过缓冲区大小，则完整主体或其一部分将写入临时文件
    client_body_buffer_size 512k;
    #指定等待client发送一个请求头的超时时间
    client_header_timeout 3m;
    #该指令设置请求体（request body）的读超时时间
    client_body_timeout 3m;
    #客户端请求头部的缓冲区大小，getconf PAGESIZE 查看系统分页大小
    client_header_buffer_size 16k;
    #指定客户端的响应超时时间。这个设置不会用于整个转发器，而是在两次客户端读取操作之间。
    #如果在这段时间内，客户端没有读取任何数据，nginx就会关闭连接
    send_timeout 3m;
    #此指令禁用NGINX缓冲区并将请求体存储在临时文件中
    client_body_in_file_only off;

    #nginx跟后端服务器连接超时时间(代理连接超时)
    proxy_connect_timeout 30s;
    #连接成功后，后端服务器响应时间(代理接收超时)
    proxy_read_timeout 30s;
    proxy_send_timeout 30s;
    #设置代理服务器（nginx）保存用户头信息的缓冲区大小
    proxy_buffer_size 64k;
    #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置
    proxy_buffers 4 32k;
    #高负荷下缓冲大小（proxy_buffers*2）
    proxy_busy_buffers_size 64k;
    #设定缓存文件夹大小，大于这个值，将从upstream服务器传递请求，而不缓冲到磁盘
    proxy_temp_file_write_size 64k;
    #不允许代理端主动关闭连接
    proxy_ignore_client_abort on;

    #开启或者关闭gzip模块
    gzip on;
    #Nginx作为反向代理的时候启用，开启或者关闭后端服务器返回的结果，匹配的前提是后端服务器必须要返回包含"Via"的 header头
    gzip_proxied expired no-cache no-store private auth;
    #设置允许压缩的页面最小字节数，页面字节数从header头中的Content-Length中进行获取
    #建议设置成大于1k的字节数，小于1k可能会越压越大。
    gzip_min_length 1k;
    #设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。 例如 4 4k 代表以4k为单位，
    #按照原始数据大小以4k为单位的4倍申请内存。 4 8k 代表以8k为单位，按照原始数据大小以8k为单位的4倍申请内存。
    #如果没有设置，默认值是申请跟原始数据相同大小的内存空间去存储gzip压缩结果。
    gzip_buffers   4 16k;
    #识别http的协议版本。由于早期的一些浏览器或者http客户端，可能不支持gzip自解压，用户就会看到乱码，所以做一些判断还是有必要的。
    # 注：21世纪都来了，现在除了类似于百度的蜘蛛之类的东西不支持自解压（百度就是SX，我就不说了），
    #99.99%的浏览器基本上都支持gzip解压了，所以可以不用设这个值,保持系统默认即可。
    gzip_http_version 1.1;
    #gzip压缩比，1 压缩比最小处理速度最快，9 压缩比最大但处理最慢（传输快但比较消耗cpu）。
    gzip_comp_level 3;
    #匹配MIME类型进行压缩，（无论是否指定）"text/html"类型总是会被压缩的。
    gzip_types    text/plain application/x-javascript text/css application/xml;
    #禁用IE6的gzip压缩，又是因为杯具的IE6。当然，IE6目前依然广泛的存在，所以这里你也可以设置为“MSIE [1-5].”
    gzip_disable "MSIE [1-6]\.";
    # 和http头有关系，加个vary头，给代理服务器用的，有的浏览器支持压缩，有的不支持，所以避免浪费不支持的也压缩，
    #所以根据客户端的HTTP头来判断，是否需要压缩
    gzip_vary on;

    include /etc/nginx/conf.d/*.conf;
}

```

## nginx_cache.conf

```bash
# nginx_cache.conf

proxy_temp_path   /usr/local/nginx/proxy_temp_dir 1 2;

# keys_zone=cache1:100m 表示这个zone名称为cache1，分配的内存大小为100MB

# /usr/local/nginx/proxy_cache_dir/cache1 表示cache1这个zone的文件要存放的目录

# levels=1:2 表示缓存目录的第一级目录是1个字符，第二级目录是2个字符，即/usr/local/nginx/proxy_cache_dir/cache1/a/1b这种形式

# inactive=1d 表示这个zone中的缓存文件如果在1天内都没有被访问，那么文件会被cache manager进程删除掉

# max_size=10g 表示这个zone的硬盘容量为10GB

proxy_cache_path  /usr/local/nginx/proxy_cache_dir/cache1  levels=1:2 keys_zone=cache1:100m inactive=1d max_size=10g;

# 在日志格式中加入$upstream_cache_status缓存命令率

log_format test_format '$remote_addr - $remote_user [$time_local]  '
    '"$request" $status $body_bytes_sent '
    '"$http_referer" "$http_user_agent" $upstream_cache_status';

# 代理服务器地址

upstream testAddr {
    server 127.0.0.1:8080;
}

server {
    listen 80;
    server_name test.com;

    access_log /usr/local/nginx/log/access.log test_format;

    #$upstream_cache_status表示资源缓存的状态，有HIT MISS EXPIRED三种状态
    add_header X-Cache $upstream_cache_status;
    location ~ .(jpg|png|gif|css|js)$ {
        proxy_pass http://testAddr;

        #设置资源缓存的zone
        proxy_cache cache1;

        #设置缓存的key
        proxy_cache_key $host$uri$is_args$args;

        #设置状态码为200和304的响应可以进行缓存，并且缓存时间为10分钟
        proxy_cache_valid 200 304 10m;

        #设置浏览器缓存时间
        expires 30d;
    }

    #重定向服务器错误页面的静态页面/ 50x.html
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }

    #拒绝访问.htaccess文件，如果Apache的文档根目录
    location ~ /\.ht {
        deny  all;
    }

    location / {
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Real-IP       $remote_addr;
        proxy_set_header Host            $http_host;

        proxy_pass http://testAddr;
    }

}

```
