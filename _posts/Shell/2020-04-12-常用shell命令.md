---
title: 常用shell命令
date: 2020-04-12 19:47:00
tags: ["脚本", "云计算", "Shell", "OpenStack"]
categories: ["Shell"]
render_with_liquid: false
permalink: /posts/2020-04-12-常用shell命令/
---

本文档介绍 常用shell命令 的相关内容。

## 实时查看指定cpu当前使用的频率

```bash
while :;do awk -F':' '/processor|cpu MHz/{print $2}' /proc/cpuinfo|xargs -n2|egrep '^(0|4|8|12|16|20|24|28|32|36|40|44|48) ';sleep 1;echo --------`date "+%Y-%m-%d %H:%M:%S"`---------;done

```

## 主机互信

```text
ssh-keygen -t rsa
ssh-copy-id -i /root/.ssh/id_rsa.pub -p 22 root@192.168.88.206

```

## 查看hardware信息，所对应cpu

```bash
yum install hwloc
lstopo-no-graphics  可以查看网卡对应的CPU核

```

## udev 查看硬件详情

```bash
# 根据内容修改硬件名称

udevadm info -a -p /sys/class/net/ens8

# 以设备名称固定网卡名

70-persistent-net.rules
DRIVERS=="virtio-pci", KERNELS=="0000:00:03.0", NAME="eth0"
DRIVERS=="igbvf", KERNELS=="0000:00:07.0", NAME="em1"
DRIVERS=="igbvf", KERNELS=="0000:00:08.0", NAME="em2"

```

## 查看当前CPU处理任务的状态

```text
mpstat -P ALL 1

%user      在internal时间段里，用户态的CPU时间(%)，不包含nice值为负进程  (usr/total)*100
%nice      在internal时间段里，nice值为负进程的CPU时间(%)   (nice/total)*100
%sys       在internal时间段里，内核时间(%)       (system/total)*100
%iowait    在internal时间段里，硬盘IO等待时间(%) (iowait/total)*100
%irq       在internal时间段里，硬中断时间(%)     (irq/total)*100
%soft      在internal时间段里，软中断时间(%)     (softirq/total)*100
%idle      在internal时间段里，CPU除去等待磁盘IO操作外的因为任何原因而空闲的时间闲置时间(%) (idle/total)*100

```

## 查看当前应用所使用的cpu

- top -d 1

- # 这里 -d 1 表示top更新的时间为一秒。
- # 默认的列是不包含当前进程对应的CPU信息的,
- # 按 f 键后,　空格选择，再按j键,　这就选上"Last Used CPU", 按回车或esc退出.
- # 这时候top界面上的Ｐ列就是对应的CPU信息.

## 配置互信

```text
ssh-keygen -t rsa
ssh-copy-id -i /root/.ssh/id_rsa.pub -p 22 root@192.168.88.206

```

## 远程执行命令，并输入密码

```ini
sshpass -p "password" ssh [user]@[hostip] "cmd"
sshpass -p "kktalk.cn" ssh root@192.168.1.1 "hostname"

```

## 循环写入磁盘

```ini
m=0;while true; do dd if=/dev/zero of=osd$m count=1 bs=512k; let m+=1;done
以512k 大小进行写入，直到写满

```

## 格式化

```bash
# 命令

df -h | head -2 | tail -l| awk '{print $2,$3,$4,$5}'
结果
Size Used Avail Use%
80G 2.7G 78G 4%

[root@bjdz-ctl-openstack01-8201 ~]# openstack server show 9bfd80ca-fb76-4c3c-a6b9-ef72f3427b05 |egrep -Ew  "id|OS-EXT-SRV-ATTR:instance_name"
| OS-EXT-SRV-ATTR:instance_name        | instance-00000314                                                                                     |
| id                                   | 9bfd80ca-fb76-4c3c-a6b9-ef72f3427b05

Ew 精确过滤

openstack server show 9852d171-b10f-403d-a421-44e0dd89f541 |egrep "addresses|flavor" |awk '{print $4}' |xargs
| xargs 把结果放在一行

```

## 批量创建文件夹

```bash
mkdir -p roles/{common,install}/{handlers,files,meta,tasks,templates,vars}

# 结果

tree roles
roles/
├── common
│   ├── files
│   ├── handlers
│   ├── meta
│   ├── tasks
│   ├── templates
│   └── vars
└── install
    ├── files
    ├── handlers
    ├── meta
    ├── tasks
    ├── templates
    └── vars

```

## shell过滤文件打包

```text
tar czvf nginx.tar.gz --exclude "nginx.conf" --exclude "vhosts" nginx/

```

## 交互选择

```ini
# !/bin/bash

ALL="
A
B
C
D
"
echo $ALL
read -p "input:" ID
echo $ALL | xargs | cut -d ' ' -f $ID

# 输入1-4分别出来A B C D

```

## grep 或操作

```bash
grep -E '123|abc' filename  // 找出文件（filename）中包含123或者包含abc的行
egrep '123|abc' filename  // 用egrep同样可以实现
awk '/123|abc/' filename // awk 的实现方式

```

## grep 与操作

```bash
grep pattern1 files | grep pattern2 ：显示既匹配 pattern1 又匹配 pattern2 的行。

```

## grep 其他操作

```bash
grep -i pattern files ：不区分大小写地搜索。默认情况区分大小写，
grep -l pattern files ：只列出匹配的文件名，
grep -L pattern files ：列出不匹配的文件名，
grep -w pattern files ：只匹配整个单词，而不是字符串的一部分（如匹配‘magic’，而不是‘magical’），
grep -C number pattern files ：匹配的上下文分别显示[number]行，

```

## 回车

```bash
# 将回车替换为‘|’

sed "$!N;s/\n/\ | /g"
多行内容转换为一行，并将每行的中间加入‘|’
sed "$!N;s/\n/\ | /g" |sed "$!N;s/\n/\ | /g"

“|”  替换的符号可以变更成其它的

```

## 过滤显示内容

```bash
# 内容太多的时候只需要显示某一段的内容

需要多个内容使用“|”
ps -ef |grep 8488fe97-eaa8-40a1-ad40-205dd705759f | egrep -o 'guest=[^,]*,|uuid [^ ]*|spice port=[0-9]*,'

# 结果

guest=instance-0000002b,
uuid 8488fe97-eaa8-40a1-ad40-205dd705759f
spice port=5900,

```

## 显示过滤的前后

```bash
只显示test1后边4行的内容，包含test1这行
openstack server list |grep test1 -A 4

只显示test1前边4行的内容，包含test1这行
openstack server list |grep test1 -B 4

显示前后四行内容
openstack server list |grep test1 -C 4

显示前后四行内容,并过滤当前行
openstack server list |grep test1 -C 4 |grep -v test1

```

## 命令行计数

```bash
包含bjdz的服务器有多少台
openstack server list |grep bjdz |wc -l

```

## 获取IP地址

```bash
ifconfig | grep inet |grep -v inet6 | awk '{print $2}' | sed 's/\/.*$//'|grep -v 127.0.0.1

# grep inet 显示包含inet的内容

# grep -v inet6 过滤掉inet6的内容

# awk '{ print $2; }' 打印第二列的内容

# grep -v 127.0.0.1 过滤127.0.0.1

# 精简版

ifconfig | grep inet |grep -v inet6 | awk '{print $2}'|grep -v 127.0.0.1

```

## 过滤分隔

```bash
hostname
devops.local

hostname |awk -F '.' '{print $1}'
devops

# awk -F '.' '{print $1;}' 以“.”号为分隔，打印打1列内容

```

## 显示颜色

```bash
# !/bin/bash

# 先定义一些颜色:

red='\e[0;41m' # 红色
RED='\e[1;31m'
green='\e[0;32m' # 绿色
GREEN='\e[1;32m'
yellow='\e[5;43m' # 黄色
YELLOW='\e[1;33m'
blue='\e[0;34m' # 蓝色
BLUE='\e[1;34m'
purple='\e[0;35m' # 紫色
PURPLE='\e[1;35m'
cyan='\e[4;36m' # 蓝绿色
CYAN='\e[1;36m'
WHITE='\e[1;37m' # 白色

NC='\e[0m' # 没有颜色

echo -e "${red}显示红色0 ${NC}"
echo -e "${RED}显示红色1 ${NC}"
echo -e "${green}显示绿色0 ${NC}"
echo -e "${GREEN}显示绿色1 ${NC}"
echo -e "${yellow}显示黄色0 ${NC}"
echo -e "${YELLOW}显示黄色1 ${NC}"
echo -e "${cyan}显示蓝绿色0 ${NC}"
echo -e "${CYAN}显示蓝绿色1 ${NC}"

```

## 多行替换sed

```bash
sed -e "s/Listen 5000/Listen 111:5000/" \
e "s/Listen 35357/Listen 222:35357/" \
i /root/wsgi-keystone.conf

```

## 获取网卡名称

```bash
ifconfig | sed -nr '/^[^ ]/h;/^ /{:a;H;n;/^$/!ba;g;/inet addr/!{s# .*$##p;};}'

```

## grep 查找二进制内容

```bash
grep "test" /home -r 查找home下所有内容中包含test的文件。

```
